package argon2id

import (
	"strings"
	"testing"
)

func TestHashPassword(t *testing.T) {
	params := Params{
		Memory:      64 * 1024,
		Iterations:  3,
		SaltLength:  16,
		KeyLength:   64,
		Parallelism: 2,
	}

	t.Run("Valid parameters", func(t *testing.T) {
		hash, err := HashPassword([]byte("password123"), &params)
		if err != nil {
			t.Fatalf("Unexpected error: %v", err)
		}

		if !strings.HasPrefix(hash, "$argon2id$v=19") {
			t.Error("Invalid hash format")
		}
	})
	t.Run("Different salts", func(t *testing.T) {
		hash1, _ := HashPassword([]byte("password123"), &params)
		hash2, _ := HashPassword([]byte("password123"), &params)

		if hash1 == hash2 {
			t.Error("Salts should be different")
		}
	})
	t.Run("Invalid parameters", func(t *testing.T) {
		badParams := params
		badParams.Memory = 7 // Меньше минимального

		_, err := HashPassword([]byte("password"), &badParams)
		if err == nil {
			t.Error("Expected error for low memory")
		}
	})
	t.Run("Invalid parameters", func(t *testing.T) {
		badParams := params
		badParams.Parallelism = 0 // Меньше минимального

		_, err := HashPassword([]byte("password"), &badParams)
		if err == nil {
			t.Error("Expected error for zero parallelism")
		}
	})
	t.Run("Invalid parameters", func(t *testing.T) {
		_, err := HashPassword([]byte("password"), nil)
		if err == nil {
			t.Error("Expected error for nil parameters")
		}
	})
	t.Run("Invalid parameters", func(t *testing.T) {
		badParams := params
		badParams.KeyLength = 3 // Меньше минимального

		_, err := HashPassword([]byte("password"), &badParams)
		if err == nil {
			t.Error("Expected error for short key length")
		}
	})
	t.Run("Invalid parameters", func(t *testing.T) {
		badParams := params
		badParams.SaltLength = 7 // Меньше минимального

		_, err := HashPassword([]byte("password"), &badParams)
		if err == nil {
			t.Error("Expected error for short salt length")
		}
	})
}

func TestGenerateRandomBytes(t *testing.T) {
	t.Run("Valid length", func(t *testing.T) {
		lengths := []uint32{16, 32, 1, 255}

		for _, l := range lengths {
			b, err := generateRandomBytes(l)
			if err != nil {
				t.Fatalf("Unexpected error for length %d: %v", l, err)
			}
			if uint32(len(b)) != l {
				t.Errorf("Incorrect length: got %d, want %d", len(b), l)
			}
		}
	})
	t.Run("Zero length", func(t *testing.T) {
		_, err := generateRandomBytes(0)
		if err == nil {
			t.Error("Expected error for zero length")
		}
	})
	t.Run("Uniqueness", func(t *testing.T) {
		const testLength uint32 = 32
		b1, _ := generateRandomBytes(testLength)
		b2, _ := generateRandomBytes(testLength)

		if string(b1) == string(b2) {
			t.Error("Generated bytes should be unique")
		}
	})
}

func TestParsePasswordHash(t *testing.T) {
	validHash := "$argon2id$v=19$m=65536,t=3,p=2$LDR8fJ6ecl1VSuxSCH/dtg$34qbOnI6Zeokj/i7lakEsR6NdwcQlFGepJk9n4Th6aAlE9gwOnI4uv75fCUN1Q9jK6yjW6QseMRO93VqzZMk2A"

	t.Run("Valid hash", func(t *testing.T) {
		parsed, err := parsePasswordHash(validHash)
		if err != nil {
			t.Fatalf("Parse failed: %v", err)
		}

		if parsed.memory != 65536 {
			t.Errorf("Wrong memory: got %d, want 65536", parsed.memory)
		}
		if len(parsed.salt) != 16 {
			t.Errorf("Wrong salt length: %d", len(parsed.salt))
		}
	})

	testCases := []struct {
		name      string
		hash      string
		expectErr string
	}{
		{
			"Wrong algorithm",
			"$argon2i$v=19$m=65536,t=3,p=2$c2FsdFNhbHQ$Rdescudv0CsGJKhSLU4sZD05YX4",
			"unsupported algorithm",
		},
		{
			"Invalid version",
			"$argon2id$v=20$m=65536,t=3,p=2$c2FsdFNhbHQ$Rdescudv0CsGJKhSLU4sZD05YX4",
			"unsupported argon2 version",
		},
		{
			"Malformed parameters",
			"$argon2id$v=19$m=65536,t=3$c2FsdFNhbHQ$Rdescudv0CsGJKhSLU4sZD05YX4",
			"invalid parameters section",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			_, err := parsePasswordHash(tc.hash)
			if err == nil || !strings.Contains(err.Error(), tc.expectErr) {
				t.Errorf("Expected error '%s', got '%v'", tc.expectErr, err)
			}
		})
	}
}

func TestVerifyPassword(t *testing.T) {
	params := Params{
		Memory:      64 * 1024,
		Iterations:  3,
		SaltLength:  16,
		KeyLength:   32,
		Parallelism: 2,
	}

	hash, _ := HashPassword([]byte("correct_password"), &params)

	t.Run("Correct password", func(t *testing.T) {
		valid, err := VerifyPassword([]byte("correct_password"), hash)
		if err != nil || !valid {
			t.Error("Should validate correct password")
		}
	})

	t.Run("Incorrect password", func(t *testing.T) {
		valid, err := VerifyPassword([]byte("wrong_password"), hash)
		if err != nil || valid {
			t.Error("Should reject wrong password")
		}
	})

	t.Run("Tampered hash", func(t *testing.T) {
		parts := strings.Split(hash, "$")
		parts[5] = "TWFuIHN0cmluZyB0byB0YW1wZXIh"
		tamperedHash := strings.Join(parts, "$")

		valid, err := VerifyPassword([]byte("correct_password"), tamperedHash)
		if err != nil || valid {
			t.Error("Should detect tampered hash")
		}
	})
	t.Run("Tampered salt", func(t *testing.T) {
		parts := strings.Split(hash, "$")
		parts[4] = "TWFuIHN0cluZyB0bdd"
		tamperedSalt := strings.Join(parts, "$")

		valid, err := VerifyPassword([]byte("correct_password"), tamperedSalt)
		if err != nil || valid {
			t.Error("Should detect tampered salt")
		}
	})
}
